[package]
name = "mmtk"
version = "0.26.0"
authors = ["The MMTk Developers <>"]
edition = "2021"
license = "MIT OR Apache-2.0"
description = "MMTk is a framework for the design and implementation of high-performance and portable memory managers."
homepage = "https://www.mmtk.io"
repository = "https://github.com/mmtk/mmtk-core"
readme = "README.md"
categories = ["memory-management"]
keywords = ["gc", "garbage", "collection", "garbage-collection", "allocation"]
rust-version = "1.71.1"
build = "build.rs"

[lib]
name = "mmtk"
crate-type = ["rlib"]
doctest = false

[dependencies]
atomic = "0.6.0"
atomic_refcell = "0.1.8"
atomic-traits = "0.4.0"
bytemuck = { version = "1.14.0", features = ["derive"] }
cfg-if = "1.0"
crossbeam = "0.8.1"
delegate = "0.12.0"
downcast-rs = "1.2"
enum-map = "2.4.2"
env_logger = { version = "0.11.3", optional = true }
humantime = "2.1.0"
is-terminal = "0.4.7"
itertools = "0.12.0"
jemalloc-sys = { version = "0.3.2", features = [
    "disable_initial_exec_tls",
], optional = true }
lazy_static = "1.4.0"
libc = "0.2"
log = { version = "0.4", features = [
    "max_level_trace",
    "release_max_level_off",
] }
memoffset = "0.9"
mimalloc-sys = { version = "0.1.6", optional = true }
# MMTk macros - we have to specify a version here in order to publish the crate, even though we use the dependency from a local path.
mmtk-macros = { version = "0.26.0", path = "macros/" }
num_cpus = "1.15.0"
num-traits = "0.2"
pfm = { git = "https://github.com/wenyuzhao/pfm.git", branch = "plm0", optional = true }
probe = { version = "0.5", optional = true }
portable-atomic = "1.4.3"
regex = { version = "1.7.0", optional = true }
spin = { version = "0.9.5", features = ["std"] }
# static_assertions = "1.1.0"
strum = "0.26.2"
strum_macros = "0.26.2"
sysinfo = { version = "0.30.9", optional = true }

[dev-dependencies]
paste = "1.0.8"
rand = "0.8.5"
criterion = "0.4"

[build-dependencies]
built = { version = "0.7.1", features = ["git2"] }

[[bench]]
name = "main"
harness = false

[features]
# default = ["sanity"]
default = [
    "perf_counter",
    "dep:sysinfo",
    "dep:regex",
    "dep:env_logger",
    # "no_meta_counting",
    "tracing",
]
# default = []
nontemporal = []
satb_timer = []
yield_and_roots_timer = []
barrier_measurement = []
barrier_measurement_no_barrier = []
barrier_measurement_no_slow = ["barrier_measurement"]
instrumentation = []
pause_time = []
survival_ratio = []
log_gc = []
log_stages = ["log_gc"]
log_work_packets = ["log_stages"]
no_meta_counting = []
field_barrier_validation = []
force_zeroing = []
no_map_fixed_noreplace = []
prefetch = []
prefetch_1k = ["prefetch"]
block_alloc_order_1 = []
block_state_reset_bug = []
fragmentation_analysis = []
periodic_fragmentation_analysis = ["fragmentation_analysis"]
g3_compatibilities = []

ss_los_16m = []
ss_tlab_4k = []
ss_tlab_8k = []
ss_tlab_16k = []
ss_tlab_32k = []
ss_tlab_64k = []
ss_tlab_128k = []
ss_tlab_256k = []
ss_tlab_512k = []
ss_tlab_1m = []
ss_tlab_2m = []
chunk_32m = []

# IX Features
ix_block_only = []
ix_no_defrag = []
ix_retry_small_object_alloc = []
ix_retry_small_object_alloc_small_only = []

# LXR Parameters
lxr_los_16k = []
lxr_los_32k = []
lxr_block_16k = []
lxr_block_32k = []
lxr_block_64k = []
lxr_block_128k = []
lxr_block_256k = []
lxr_block_512k = []
lxr_block_1m = []
lxr_line_256b = []
lxr_line_512b = []
lxr_line_1k = []
lxr_lock_3 = []
lxr_lock_4 = []
lxr_lock_5 = []
lxr_lock_6 = []
lxr_lock_7 = []
lxr_lock_8 = []
lxr_lock_9 = []
lxr_buf_256 = []
lxr_buf_512 = []
lxr_buf_1024 = []
lxr_buf_2048 = []
lxr_rc_bits_2 = []
lxr_rc_bits_4 = []
lxr_rc_bits_8 = []

# LXR Features
lxr_hole_counting = []
lxr_no_rc_in_cm = []
lxr_no_cm = []
lxr_no_lazy = []
lxr_stw = ["lxr_no_cm", "lxr_no_lazy"]
lxr_no_nursery_evac = []
lxr_no_mature_evac = []
lxr_no_evac = ["lxr_no_nursery_evac", "lxr_no_mature_evac"]
lxr_evacuate_nursery_in_recycled_lines = []
lxr_delayed_nursery_evacuation = []
lxr_enable_initial_alloc_limit = []
lxr_report_fragmentation = []
madv_dontneed = []
munmap = []
lxr_no_survival_trigger = []
object_size_distribution = []
lxr_srv_ratio_counter = []
lxr_fixed_young_size = []
lxr_satb_live_bytes_counter = []
rust_mem_counter = []
lxr_fixed_satb_trigger = []
lxr_precise_incs_counter = []
lxr_no_lazy_young_sweeping = []
ix_always_defrag = []
ix_live_size_based_defrag = []
ix_no_defrag_fix = []
lxr_no_chunk_defrag = []
lxr_release_stage_timer = []
report_worker_sleep_events = []
log_outstanding_packets = []
log_all_inc_packets = []
lxr_no_srv_copy_reserve = []
lxr_abort_on_trace = []
lxr_log_reclaim = []
lxr_simple_satb_trigger = []
measure_trace_rate = []
measure_rc_rate = []
lxr_no_mature_defrag = []
aggressive_mature_evac = []
decs_counter = []
remset_counter = []
lxr_no_decs = []
lxr_no_recursive_dec = []
lxr_no_prefetch = []
utilization = []
stack = []

fixed_alloc_trigger_based_on_system_time = []

bpr_unprioritized = []
bpr_freelist = []
freelist_best_fit_alloc = []
bpr_spin_lock = []

# This feature is only supported on x86-64 for now
# It's manually added to CI scripts
perf_counter = ["pfm"]
perf_counter_plm0 = ["perf_counter", "pfm/plm0"]
work_packet_counter = []

# This feature is only used for tests with MockVM.
# CI scripts run those tests with this feature.
mock_test = []

# .github/scripts/ci-common.sh extracts features from the following part (including from comments).
# So be careful when editing or adding stuff to the section below.


# Do not modify the following line - ci-common.sh matches it
# -- Non mutually exclusive features --

# spaces with different semantics

# A VM-allocated/managed space. A binding could use this for their boot image, metadata space, etc.
# FIXME: This is not properly implemented yet (it is only working for JikesRVM): https://github.com/mmtk/mmtk-core/issues/415
# If a binding would need to trace/scan objects that is allocated and managed by the VM, `ActivePlan::vm_trace_object()` is an alternative.
vm_space = []

# A readonly space.
# TODO: This is not properly implemented yet. We currently use an immortal space instead, and do not guarantee read-only semantics.
ro_space = []
# A code space with execution permission.
# TODO: This is not properly implemented yet. We currently use an immortal space instead, and all our spaces have execution permission at the moment.
code_space = []

# Global valid object (VO) bit metadata.
# The VO bit is set when an object is allocated, and cleared when the GC determines it is dead.
# See `src/util/metadata/vo_bit/mod.rs`
#
# eager_sweeping: VO bits for dead objects must have been cleared by the end of each GC.
# Native MarkSweep only ensures this in eager sweeping mode.
vo_bit = ["eager_sweeping"]

# conservative garbage collection support
is_mmtk_object = ["vo_bit"]

# Enable object pinning, in particular, enable pinning/unpinning, and its metadata
object_pinning = []

# The following two features are useful for using Immix for VMs that do not support moving GC.

# Disable any object copying in Immix. This makes Immix a non-moving policy.
immix_non_moving = []

# Disable any object copying in nursery GC for Sticky Immix while allowing other kinds of copying.
# `immix_non_moving` disables all kinds of copying in Immix, so this feature is not needed
# if `immix_non_moving` is in use.
sticky_immix_non_moving_nursery = []


# Reduce block size for ImmixSpace.  This mitigates fragmentation when defrag is disabled.
immix_smaller_block = []
# Zero the unmarked lines after a GC cycle in immix. This helps debug untraced objects.
immix_zero_on_release = []

# Run sanity GC
sanity = []
# Run analysis
analysis = []
# Use lock free variant of NoGC
nogc_lock_free = []
# Use lock free with no zeroing NoGC
nogc_no_zeroing = ["nogc_lock_free"]
# For using a single GC thread
# Q: Why do we need this as a compile time flat? We can always set the number of GC threads through options.
single_worker = []

# To run expensive comprehensive runtime checks, such as checking duplicate edges
extreme_assertions = []

# Enable multiple spaces for NoGC, each allocator maps to an individual ImmortalSpace.
nogc_multi_space = []

# To collect statistics for each GC work packet. Enabling this may introduce a small overhead (several percentage slowdown on benchmark time).
work_packet_stats = []

# Count the malloc'd memory into the heap size
malloc_counted_size = []

# Count the size of all live objects in GC
count_live_bytes_in_gc = []

# Workaround a problem where bpftrace scripts (see tools/tracing/timeline/capture.bt) cannot
# capture the type names of work packets.
bpftrace_workaround = []

# Do not modify the following line - ci-common.sh matches it
# -- Mutally exclusive features --
# Only one feature from each group can be provided. Otherwise build will fail.

# Name of the mutualy exclusive feature group. ci-common.sh matches lines like this one.
# Group:malloc
# only one of the following features should be enabled, or none to use the default malloc from libc
# this does not replace the global Rust allocator, but provides these libraries for GC implementation
malloc_mimalloc = ["mimalloc-sys"]
malloc_jemalloc = ["jemalloc-sys"]

# Use the native mimalloc allocator for malloc. This is not tested by me (Yi) yet, and it is only used to make sure that some code
# is not compiled in default builds.
malloc_native_mimalloc = []

# If there are more groups, they should be inserted above this line
# Group:end

# Group:marksweepallocation
# default is native allocator with lazy sweeping
eager_sweeping = []
# Use library malloc as the freelist allocator for mark sweep. This will makes mark sweep slower. As malloc may return addresses outside our
# normal heap range, we will have to use chunk-based SFT table. Turning on this feature will use a different SFT map implementation on 64bits,
# and will affect all the plans in the build. Please be aware of the consequence, and this is only meant to be experimental use.
malloc_mark_sweep = []
# Group:end

tracing = ["probe"]
flush_half = []
